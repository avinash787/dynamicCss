<!DOCTYPE html>
<html>
<head>
  <title>Virtual DOM Example</title>
</head>
<body>
  <div id="app">
    <div class="container">
      <h1>Hello, World!</h1>
    </div>
  </div>

  <script>
    // Virtual DOM Library

    class VNode {
      constructor(tagName, props, children) {
        this.tagName = tagName;
        this.props = props || {};
        this.children = children || [];
      }
    }

    function createVNode(tagName, props, children) {
      return new VNode(tagName, props, children);
    }

    // Keep track of the real DOM elements associated with each VNode
    const elementCache = {};

    function diff(oldVNode, newVNode) {
      if (typeof oldVNode === 'string' || typeof newVNode === 'string') {
        // Handle text node diffing
        if (oldVNode !== newVNode) {
          return newVNode;
        }
      }
      if (oldVNode.tagName !== newVNode.tagName) {
        // If the tag names are different, replace the old node with the new one
        return newVNode;
      }

      const patch = {
        type: 'UPDATE',
        props: {},
        children: [],
      };

      // Diff props
      const allProps = { ...oldVNode.props, ...newVNode.props };
      for (const prop in allProps) {
        if (newVNode.props[prop] !== oldVNode.props[prop]) {
          patch.props[prop] = newVNode.props[prop];
        }
      }

      // Diff children
      const oldChildren = oldVNode.children;
      const newChildren = newVNode.children;
      const maxLength = Math.max(oldChildren.length, newChildren.length);
      for (let i = 0; i < maxLength; i++) {
        const oldChild = oldChildren[i];
        const newChild = newChildren[i];
        if (oldChild && newChild) {
          // Recursively diff the children
          const childPatch = diff(oldChild, newChild);
          patch.children.push(childPatch);
        } else if (newChild) {
          // If a new child exists, it's an addition
          patch.children.push({
            type: 'ADD',
            vnode: newChild,
          });
        } else if (oldChild) {
          // If an old child exists, it's a removal
          patch.children.push({
            type: 'REMOVE',
            vnode: oldChild,
          });
        }
      }

      return patch;
    }

    
function updateElement(target, patch) {
      // Helper function to apply props
      function applyProps(element, props) {
        for (const [prop, value] of Object.entries(props)) {
          if (prop === 'style') {
            for (const [styleProp, styleValue] of Object.entries(value)) {
              element.style[styleProp] = styleValue;
            }
          } else if (prop in element) {
            element[prop] = value;
          } else {
            element.setAttribute(prop, value);
          }
        }
      }

      // Helper function to apply patches to children
      function applyChildPatches(parent, patches) {
        for (const patch of patches) {
          if (patch.type === 'UPDATE') {
            applyPatch(parent, patch);
          } else if (patch.type === 'ADD') {
            const newChild = createRealDOMFromVNode(patch.vnode);
            parent.appendChild(newChild);
          } else if (patch.type === 'REMOVE') {
            // Remove the real DOM element associated with the VNode from the cache
            const childElement = elementCache[patch.vnode];
            if (childElement) {
              parent.removeChild(childElement);
              delete elementCache[patch.vnode];
            }
          }
        }
      }

      // Helper function to apply a single patch
      function applyPatch(parent, patch) {
        if (patch.type === 'UPDATE') {
          if (patch.props) {
            applyProps(parent, patch.props);
          }

          // Recursively apply patches to children
          const children = parent.childNodes;
          for (let i = 0; i < patch.children.length; i++) {
            applyChildPatches(children[i], [patch.children[i]]);
          }
        } else if (patch.type === 'ADD') {
          const newChild = createRealDOMFromVNode(patch.vnode);
          parent.appendChild(newChild);
        } else if (patch.type === 'REMOVE') {
          // Remove the real DOM element associated with the VNode from the cache
          const childElement = elementCache[patch.vnode];
          if (childElement) {
            parent.removeChild(childElement);
            delete elementCache[patch.vnode];
          }
        } else if (typeof patch === 'string') {
          // Handle text node patch
          parent.textContent = patch;
        }
      }

      // Call the initial patch function with the root target
      applyPatch(target, patch);
    }




    function createRealDOMFromVNode(vnode) {
      if (typeof vnode === 'string') {
        return document.createTextNode(vnode);
      }

      const el = document.createElement(vnode.tagName);

      for (const [key, value] of Object.entries(vnode.props)) {
        el.setAttribute(key, value);
      }

      vnode.children.forEach((child) => {
        el.appendChild(createRealDOMFromVNode(child));
      });

      return el;
    }

    // Virtual DOM Example

    function render(vnode, container) {
      const realDOM = createRealDOMFromVNode(vnode);
      container.appendChild(realDOM);
    }

    function update(oldVNode, newVNode, container) {
      const patch = diff(oldVNode, newVNode);
      updateElement(container, patch);
    }

    // Extract the initial virtual DOM tree from the real DOM
    const container = document.getElementById('app');
    const initialVNode = createVNode(container.tagName.toLowerCase(), getAttributes(container), getChildNodes(container));

    // Helper function to extract attributes from an element
    function getAttributes(element) {
      const attributes = {};
      const attrs = element.attributes;
      for (let i = 0; i < attrs.length; i++) {
        attributes[attrs[i].name] = attrs[i].value;
      }
      return attributes;
    }

    // Helper function to extract child nodes from an element
    function getChildNodes(element) {
      const children = [];
      for (let i = 0; i < element.childNodes.length; i++) {
        const child = element.childNodes[i];
        if (child.nodeType === Node.TEXT_NODE) {
          children.push(child.textContent);
        } else if (child.nodeType === Node.ELEMENT_NODE) {
          children.push(createVNode(child.tagName.toLowerCase(), getAttributes(child), getChildNodes(child)));
        }
      }
      return children;
    }

    // After a while, update the virtual DOM and the real DOM
    setTimeout(() => {
      const newVNode = createVNode('div', { class: 'container' }, [
        createVNode('h1', {}, ['Hello, Virtual DOM!']),
      ]);

      update(initialVNode, newVNode, container);
    }, 5000);
  </script>
</body>
</html>
