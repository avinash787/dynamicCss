<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual DOM Example</title>
</head>
<body>
  <div id="root">
    <!-- The virtual DOM will be rendered here -->
  </div>

  <script>
    // Represents a virtual DOM element
    class VNode {
      constructor(tagName, props, children) {
        this.tagName = tagName;
        this.props = props || {};
        this.children = children || [];
      }
    }

    // Helper function to create a new virtual DOM element
    function createElement(tagName, props, children) {
      return new VNode(tagName, props, children);
    }



    // Diffing algorithm
function diff(oldVNode, newVNode) {
  if (!oldVNode) {
    // If there's no old VNode, everything is new
    return newVNode;
  }

  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {
    // If either oldVNode or newVNode is a string (text node),
    // and they are different, replace the old node with the new one
    if (oldVNode !== newVNode) {
    return {
      type: 'TEXT',
      content: newVNode,
    };
  } else {
    return null; // No update needed for text nodes with the same content
  }
  }

  if (oldVNode.tagName !== newVNode.tagName) {
    // If the tag names are different, replace the old node with the new one
    return newVNode;
  }

  const patch = {
    type: 'UPDATE',
    props: {},
    children: [],
  };

  // Diff props
  const allProps = { ...oldVNode.props, ...newVNode.props };
  for (const prop in allProps) {
    if (newVNode.props[prop] !== oldVNode.props[prop]) {
      patch.props[prop] = newVNode.props[prop];
    }
  }

  // Diff children
  const oldChildren = oldVNode.children || [];
  const newChildren = newVNode.children || [];
  const maxLength = Math.max(oldChildren.length, newChildren.length);
  for (let i = 0; i < maxLength; i++) {
    const oldChild = oldChildren[i];
    const newChild = newChildren[i];
    const childPatch = diff(oldChild, newChild);
    if (childPatch) {
      // Only add the child patch if it's not null (meaning no update is needed)
      patch.children.push(childPatch);
    }
  }
  console.log(patch)
  return patch;
}



// Helper function to apply patches and update the real DOM
function applyPatch(node, patch) {
  switch (patch.type) {
    case 'UPDATE':
      if (typeof node === 'string' || typeof patch.props === 'string') {
        // If either node or patch is a string (text node),
        // update the textContent of the node
        if (node.textContent !== patch.props) { // <- Corrected comparison
          node.textContent = patch.props;
        }
      } else {
        for (const prop in patch.props) {
          node[prop] = patch.props[prop];
        }
        patch.children.forEach((childPatch, index) => {
          applyPatch(node.childNodes[index], childPatch);
        });
      }
      break;
    case 'ADD':
      const newNode = createDOMNode(patch.vnode);
      node.appendChild(newNode);
      break;
    case 'REMOVE':
      node.removeChild(node.childNodes[patch.index]);
      break;
    case 'TEXT':
      if (node.textContent !== patch.content) {
         node.textContent = patch.content;
      }
      break;
  }
}

// Helper function to convert a virtual DOM element to a real DOM node
function createDOMNode(vnode) {
  if (typeof vnode === 'string') {
    return document.createTextNode(vnode);
  }

  const node = document.createElement(vnode.tagName);
  for (const prop in vnode.props) {
    node[prop] = vnode.props[prop];
  }

  vnode.children.forEach((child) => {
    const childNode = createDOMNode(child);
    node.appendChild(childNode);
  });

  return node;
}

    let oldVNode = createElement('div', { id: 'container', class: 'grid' }, [
        createElement('h1', { style: { color: 'blue' } }, ['Hello, Updated Virtual DOM!']),
        createElement('div', {}, [
          createElement('h3', { style: { color: 'red' } }, ['Hello']),
          createElement('button', { style: { color: 'green' } }, ['Hello']),
        ]),
        createElement('a', { href: "www.xyz.com" }, ['new link']),
      ]);

    // Initial render
    const rootElement = document.getElementById('root');
    const rootNode = createDOMNode(oldVNode);
    rootElement.appendChild(rootNode);

    function update() {
      const newVNode = createElement('div', { id: 'container', class: 'grid' }, [
        createElement('h1', { style: { color: 'blue' } }, ['Hello, Updated Virtual DOM!']),
        createElement('div', {}, [
          createElement('h3', { style: { color: 'red' } }, ['Hello']),
          createElement('button', { style: { color: 'green' } }, ['Hello']),
        ]),
        createElement('a', { href: "www.xyz.com" }, ['new link']),
      ]);

      // Diff the old and new virtual DOM
      //console.log(oldVNode, newVNode)
      const patch = diff(oldVNode, newVNode);

      // Apply the patch and update the real DOM
      applyPatch(rootNode, patch);

      // Update the oldVNode to the newVNode for the next update
      oldVNode = newVNode;
    }

    // Simulate dynamic updates every 3 seconds
    setTimeout(update, 0);
  </script>
</body>
</html>
