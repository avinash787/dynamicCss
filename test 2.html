<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual DOM Example</title>
</head>
<body>
  <div id="root">
    <!-- The virtual DOM will be rendered here -->
  </div>

  <script>
    // Represents a virtual DOM element
    class VNode {
      constructor(tagName, props, children, textNode) {
        this.tagName = tagName;
        this.props = props || {};
        this.children = children || [];
        this.innerNode = textNode || "";
      }
    }

    // Helper function to create a new virtual DOM element
    function createElement(tagName, props, children, textNode) {
      return new VNode(tagName, props, children, textNode);
    }

    // Sample virtual DOM
    let oldVNode = createElement('div', { id: 'container', class: 'grid' }, []);

    // Helper function to convert a virtual DOM element to a real DOM node
    function createDOMNode(vnode) {
      if (typeof vnode === 'string') {
        return document.createTextNode(vnode);
      }

      const node = document.createElement(vnode.tagName);
      for (const prop in vnode.props) {
        if (prop === 'class') {
          node.className = vnode.props[prop];
        } else if (prop === 'style') {
          // Handle inline styles
          const styleObject = vnode.props[prop];
          for (const styleProp in styleObject) {
            node.style[styleProp] = styleObject[styleProp];
          }
        } else {
          // Set other attributes directly
          node.setAttribute(prop, vnode.props[prop]);
        }
      }

      vnode.children.forEach((child) => {
        const childNode = createDOMNode(child);
        node.appendChild(childNode);
      });

      if (vnode.innerNode) {
        node.appendChild(document.createTextNode(vnode.innerNode));
      }

      return node;
    }

    // Helper function to check if two objects are shallowly equal
    function shallowEqual(obj1, obj2) {
      if (obj1 === obj2) {
        return true;
      }

      if (obj1 == null || obj2 == null) {
        return false;
      }

      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);

      if (keys1.length !== keys2.length) {
        return false;
      }

      for (const key of keys1) {
        if (obj1[key] !== obj2[key]) {
          return false;
        }
      }

      return true;
    }

    // Function to diff the old and new virtual DOM
    function diff(oldVNode, newVNode, parentNode) {
  if (oldVNode === newVNode) {
    // If both oldVNode and newVNode are the same, no update needed
    return null;
  }

  if (typeof oldVNode === 'string' || typeof newVNode === 'string') {
    // If either oldVNode or newVNode is a string (text node),
    // and they are different, create a new patch for text nodes
    if (oldVNode !== newVNode) {
      return {
        type: 'TEXT',
        content: newVNode,
      };
    } else {
      return null; // No update needed for text nodes with the same content
    }
  }

  if (oldVNode.tagName !== newVNode.tagName) {
    // If the tag names are different, replace the old node with the new one
    return newVNode;
  }

  // If the tag names and keys are the same, we need to diff props and children
  const patch = {
    type: 'UPDATE',
    props: {},
    children: [],
  };

  // Diff props
  const allProps = { ...oldVNode.props, ...newVNode.props };
  for (const prop in allProps) {
    if (!shallowEqual(newVNode.props[prop], oldVNode.props[prop])) {
      patch.props[prop] = newVNode.props[prop];
    }
  }

  // Diff children
  const oldChildren = oldVNode.children || [];
  const newChildren = newVNode.children || [];
  const commonLength = Math.min(oldChildren.length, newChildren.length);
  for (let i = 0; i < commonLength; i++) {
    const oldChild = oldChildren[i];
    const newChild = newChildren[i];
    const childPatch = diff(oldChild, newChild, parentNode); // Pass the parent node reference
    if (childPatch) {
      // Only add the child patch if it's not null (meaning no update is needed)
      patch.children.push(childPatch);
    }
  }

  if (oldChildren.length > newChildren.length) {
    // If oldVNode has more children, create REMOVE patches for the extra ones
    for (let i = commonLength; i < oldChildren.length; i++) {
      patch.children.push({
        type: 'REMOVE',
        index: i,
      });
    }
  } else if (newChildren.length > oldChildren.length) {
    // If newVNode has more children, create ADD patches for the extra ones
    for (let i = commonLength; i < newChildren.length; i++) {
      patch.children.push({
        type: 'ADD',
        vnode: newChildren[i],
        parentNode: parentNode, // Store the parent node where the new element should be added
      });
    }
  }

  return patch;
}

    // Function to apply the patch and update the real DOM
   // Function to apply the patch and update the real DOM
function applyPatch(node, patch) {
  switch (patch.type) {
    case 'UPDATE':
      if (typeof patch.content === 'string') {
        // If either node or patch is a string (text node),
        // update the textContent of the node
        if (node.textContent !== patch.content) {
          node.textContent = patch.content;
        }
      } else {
        for (const prop in patch.props) {
          if (prop === 'style') {
            // Handle inline styles
            const styleObject = patch.props[prop];
            for (const styleProp in styleObject) {
              node.style[styleProp] = styleObject[styleProp];
            }
          } else {
            // Set other attributes directly
            node.setAttribute(prop, patch.props[prop]);
          }
        }
        patch.children.forEach((childPatch, index) => {
          applyPatch(node.childNodes[index], childPatch);
        });
      }
      break;
    case 'ADD':
      const newNode = createDOMNode(patch.vnode);
      if (patch.parentNode) {
        // Check if the parent node exists before appending the new node
        node.appendChild(newNode);
      } else {
        console.error("Parent node is undefined for an 'ADD' patch. Cannot add the new element.");
      }
      break;
    case 'REMOVE':
      node.removeChild(node.childNodes[patch.index]);
      break;
    case 'TEXT':
      if (node.textContent !== patch.content) {
        node.textContent = patch.content;
      }
      break;
  }
}



    // Render the virtual DOM to the real DOM
    function render(vnode, container) {
      // Clear the container before rendering
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }

      const rootNode = createDOMNode(vnode);
      container.appendChild(rootNode);
    }

    function updateDOM() {
      // Sample updated virtual DOM
      const newVNode = createElement('div', { id: 'container', class: 'grid' }, [
        createElement('h1', { style: { color: 'green' } }, ['Hello, Updated Virtual DOM!'])
      ]);

      // Diff the old and new virtual DOM
      const patch = diff(oldVNode, newVNode);

      // Apply the patch and update the real DOM
      const rootElement = document.getElementById('root');
      applyPatch(rootElement.firstChild, patch);

      // Update the oldVNode to the newVNode for the next update
      oldVNode = newVNode;
    }

    // Initial render
    const rootElement = document.getElementById('root');
    render(oldVNode, rootElement);

    // Simulate dynamic updates every 3 seconds
    setInterval(updateDOM, 3000);
  </script>
</body>
</html>
